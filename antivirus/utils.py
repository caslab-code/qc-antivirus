from typing import Dict, List, Tuple, Union, Optional, Generator
from qiskit import QuantumCircuit
from qiskit.qobj import Qobj
from qiskit.qobj.qasm_qobj import QasmQobj, QasmQobjInstruction
from circuit_to_dagnc import circuit_to_dagnc
from networkx import MultiDiGraph
from retworkx import PyDAG



def circuit_to_network(
    qc: Union[QuantumCircuit, QasmQobj, Qobj, List[QasmQobjInstruction]],
    network_type : str = "networkx"
    ) -> MultiDiGraph:
    """Convert a quantum circuit to ``networkx.MultiDiGraph``

    Args:
        qc: The quantum circuit to be converted.
        network_type: The package for the graph representation. If set to ``networkx``,
            ``networkx.algorithms.isomorphism.DiGraphMatcher`` is used; if set to ``retworkx``,
            ``retworkx.vf2_mapping`` is used.
    
    Yiled:
        The matching of a pattern in a quantum circuit.
    """
    if network_type == "networkx":
        qc_dag = circuit_to_dagnc(qc)
        qc_net = qc_dag.to_networkx()
        return qc_net
    if network_type == "retworkx":
        qc_dag = circuit_to_dagnc(qc)
        qc_net = qc_dag.to_retworkx()
        return qc_net
    else:
        raise Exception("Please specify the network type!")



def check_matching(
    matching: Dict
    ) -> bool:
    """Check whether the matching is correct.
        This function is used to check the results of networkx isomorphism.
        Because the networkx isomorphism checking does not check qubits on which gates operate,
        it only returns the matching that has the same gates and order. In this case, the qubits
        mapping may not be satisfied. For example, the pattern is h(0) and cx(0, 1), but the
        matching is h(1) and cx(0, 1). This is viewed as a correct matching in the networkx
        isomorphism, but this should not be a matching in our antivirus program.

    Args:
        matching: item generated by ``networkx.algorithms.isomorphism.DiGraphMatcher.subgraph_isomorphisms_iter()``,
            which is the matching found by vf2 subgraph isomorphism algorithm.
    
    Return:
        Whether the matching is a correct matching.
    """

    qargs = {} # store qubits mapping of currently transversed gates
    cargs = {} # store clbits mapping of currently transversed gates

    # Eaching matching is a ``dict``. The key is the node in the first graph, and the corresponding value is the matching node in the second graph
    for node_qc, node_pt in matching.items():
        for qubit_qc, qubit_pt in zip(node_qc.qargs, node_pt.qargs):
            if qubit_qc.index in qargs:
                if qubit_pt.index != qargs[qubit_qc.index]:
                    return False
            else:
                qargs[qubit_qc.index] = qubit_pt.index
    
        for qubit_qc, qubit_pt in zip(node_qc.cargs, node_pt.cargs):
            if qubit_qc.index in cargs:
                if qubit_pt.index != cargs[qubit_qc.index]:
                    return False
            else:
                cargs[qubit_qc.index] = qubit_pt.index
    
    return True



def get_mapping(
    matching: Dict
    ) -> Dict:
    """return the qubit and clbit indices mapping of the matching first item to the second item

    Args:
        matching: the matching returned by subgraph isomorphism searching. Eaching matching
            is a ``dict``. The key is the node in the first graph, and the corresponding value 
            is the matching node in the second graph.

    Returns:
        A ``Tuple``, whose first item is qubit indices mapping, and the second item is clbit
        indices mapping. The mapping is a ``Dict``, whose keys are the indices in the first
        graph, and values are the indices in the second graph.
    """

    qargs = {} # store qubits mapping of currently transversed gates
    cargs = {} # store clbits mapping of currently transversed gates

    # Eaching matching is a ``dict``. The key is the node in the first graph, and the corresponding value is the matching node in the second graph
    for node_qc, node_pt in matching.items():
        for qubit_qc, qubit_pt in zip(node_qc.qargs, node_pt.qargs):
            if qubit_qc.index in qargs:
                if qubit_pt.index != qargs[qubit_qc.index]:
                    break
            else:
                qargs[qubit_qc.index] = qubit_pt.index
    
        for qubit_qc, qubit_pt in zip(node_qc.cargs, node_pt.cargs):
            if qubit_qc.index in cargs:
                if qubit_pt.index != cargs[qubit_qc.index]:
                    break
            else:
                cargs[qubit_qc.index] = qubit_pt.index
    
    return (qargs, cargs)

