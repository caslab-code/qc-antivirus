from qiskit import QuantumCircuit
from qiskit.qobj import Qobj
from qiskit.qobj.qasm_qobj import QasmQobj, QasmQobjInstruction
from qiskit.dagcircuit.dagdepnode import DAGDepNode

from networkx import MultiDiGraph
from retworkx import PyDAG

from typing import Dict, List, Tuple, Union, Optional
from collections import OrderedDict

from dagnc import DAGNC
from circuit_to_dagnc import circuit_to_dagnc



def circuit_to_network(
    qc: QuantumCircuit, 
    network_type : str = "networkx"
    ) -> MultiDiGraph or PyDAG:
    """Convert a quantum circuit to ``networkx.MultiDiGraph`` or ``retworkx.PyDAG``.

    Args:
        qc: The quantum circuit to be converted.
        network_type: The package for the graph representation. If set to ``"networkx"``,
            the quantum circuit is converted to ``networkx.MultiDiGraph``; if set to 
            ``"retworkx"``, the quantum circuit is converted to ``retworkx.PyDAG``;
    
    Return:
        The graph representation of a quantum circuit.
    """

    if network_type == "networkx":
        qc_dag = circuit_to_dagnc(qc)
        qc_net = qc_dag.to_networkx()
        return qc_net
    if network_type == "retworkx":
        qc_dag = circuit_to_dagnc(qc)
        qc_net = qc_dag.to_retworkx()
        return qc_net
    else:
        raise Exception("Please specify the network type!")



def check_matching(
    matching: Dict
    ) -> bool:
    """Check whether the matching is correct.
        This function is used to check the results of networkx isomorphism.
        Because the networkx isomorphism checking does not check qubits on which gates operate,
        it only returns the matching that has the same gates and order. In this case, the qubits
        mapping may not be satisfied. For example, the pattern is h(0) and cx(0, 1), but the
        matching is h(1) and cx(0, 1). This is viewed as a correct matching in the networkx
        isomorphism, but this should not be a matching in our antivirus program.

    Args:
        matching: item generated by ``networkx.algorithms.isomorphism.DiGraphMatcher.subgraph_isomorphisms_iter()``,
            which is the matching found by vf2 subgraph isomorphism algorithm.
    
    Return:
        Whether the matching is a correct matching.
    """

    qargs = {} # store qubits mapping of currently transversed gates
    cargs = {} # store clbits mapping of currently transversed gates

    # Eaching matching is a ``dict``. The key is the node in the first graph, and the corresponding value is the matching node in the second graph
    for node_qc, node_pt in matching.items():
        for qubit_qc, qubit_pt in zip(node_qc.qargs, node_pt.qargs):
            if qubit_qc.index in qargs:
                if qubit_pt.index != qargs[qubit_qc.index]:
                    return False
            else:
                qargs[qubit_qc.index] = qubit_pt.index
    
        for clbit_qc, clbit_pt in zip(node_qc.cargs, node_pt.cargs):
            if clbit_qc.index in cargs:
                if clbit_pt.index != cargs[clbit_qc.index]:
                    return False
            else:
                cargs[clbit_qc.index] = clbit_pt.index
    
    return True



def get_bits_mapping(
    matching: Dict
    ) -> Tuple[Dict, Dict]:
    """return the qubit and clbit indices mapping of the matching first item to the second item

    Args:
        matching: the matching returned by subgraph isomorphism searching. Eaching matching
            is a ``dict``. The key is the node in the first graph, and the corresponding value 
            is the matching node in the second graph.

    Returns:
        A ``Tuple``, whose first item is qubit indices mapping, and the second item is clbit
        indices mapping. The mapping is a ``Dict``, whose keys are the indices in the first
        graph, and values are the indices in the second graph.
    """

    qargs = {} # store qubits mapping of currently transversed gates
    cargs = {} # store clbits mapping of currently transversed gates

    # Eaching matching is a ``dict``. The key is the node in the first graph, and the corresponding value is the matching node in the second graph
    for node_qc, node_pt in matching.items():
        for qubit_qc, qubit_pt in zip(node_qc.qargs, node_pt.qargs):
            if qubit_qc.index in qargs:
                if qubit_pt.index != qargs[qubit_qc.index]:
                    raise Exception("Wrong subgraph isomorphism!")
            else:
                qargs[qubit_qc.index] = qubit_pt.index
    
        for clbit_qc, clbit_pt in zip(node_qc.cargs, node_pt.cargs):
            if clbit_qc.index in cargs:
                if clbit_pt.index != cargs[clbit_qc.index]:
                    raise Exception("Wrong subgraph isomorphism!")
            else:
                cargs[clbit_qc.index] = clbit_pt.index
    
    return (qargs, cargs)



def nxmatching_to_id(
    matching: Dict,
    sort_pt: bool = False
    ) -> OrderedDict:
    """return the qubit and clbit indices mapping of the matching first item to the second item

    Args:
        matching: the matching returned by subgraph isomorphism searching. Eaching matching
            is a ``dict``. The key is the node in the first graph, and the corresponding value 
            is the matching node in the second graph.
        sort_pt: whether to sort ascendingly based on the indices of the pattern nodes

    Returns:
        A ``OrderedDict``, whose keys are node indices in the quantum circuit, and values are
            node indices in the pattern.
    """

    mapping_nodes_id = OrderedDict()

    for node_qc, node_pt in matching.items():
        mapping_nodes_id[node_qc.node_id] = node_pt.node_id
    
    if sort_pt:
        mapping_nodes_id = OrderedDict(sorted(mapping_nodes_id.items(), key = lambda x: x[1]))

    return mapping_nodes_id



def reduce_qc(
    qc_dagnc: DAGNC,
    qubit_list: Optional[List[int]] = None,
    clbit_list: Optional[List[int]] = None,
    # register_list: Optional[List[int]] = None
    is_node_id: bool = False
    ) -> List[DAGDepNode or int]:
    """Return the reduced node set of the qc_dagnc, i.e., all nodes that involve qubits in qubit_list
            or clbits in clbit_list. The node id is ordered.

    Args:
        qc_dagnc: The quantum circuit to be searched through.
        qubit_list: The list of qubit indices to be considered.
        clbit_list: The list of memory indices to be considered.
        # register_list: The list of register indices to be considered.
    
    Returns:
        The reduced node set of the qc_dagnc, i.e., all nodes that involve qubits in qubit_list
            or clbits in clbit_list.
    """

    reduced_nodes = []
    for node in qc_dagnc.get_nodes():
        if qubit_list:
            for qindex in node.qindices:
                if qindex in qubit_list:
                    if is_node_id:
                        reduced_nodes.append(node.node_id)
                    else:
                        reduced_nodes.append(node)
                    break
        if clbit_list:
            for cindex in node.cindices:
                if cindex in clbit_list:
                    if is_node_id:
                        reduced_nodes.append(node.node_id)
                    else:
                        reduced_nodes.append(node)
                    break

    return reduced_nodes



def count_num_bits(
    qc: Union[QuantumCircuit, QasmQobj, Qobj, List[QasmQobjInstruction]],
    bit_type: str = 'qubit'
    ) -> int:
    """Return the number of qubits or clbites of the given input.

    Args:
        qc: The input to count qubits. 
        bit_type: The type of the bits: one of ```qubit```, ```clbit```.

    Returns:
        The number of qubits in the given input.
    """

    if bit_type == 'qubit':
        if isinstance(qc, QuantumCircuit):
            num_bits = qc.num_qubits
        elif isinstance(qc, (QasmQobj, Qobj)):
            num_bits = qc.config.n_qubits
        elif isinstance(qc, List) and isinstance(qc[0], QasmQobjInstruction):
            num_bits = 0
            qubit_set = []
            for ins in qc:
                if hasattr(ins, 'qubits'):
                    for qubit in ins.qubits:
                        if qubit not in qubit_set:
                            num_bits += 1
                            qubit_set.append(qubit)
    
    elif bit_type == 'clbit':
        if isinstance(qc, QuantumCircuit):
            num_bits = qc.num_clbits
        elif isinstance(qc, (QasmQobj, Qobj)):
            num_bits = qc.config.memory_slots
        elif isinstance(qc, List) and isinstance(qc[0], QasmQobjInstruction):
            num_bits = 0
            clbit_set = []
            for ins in qc:
                if hasattr(ins, 'memory'):
                    for clbit in ins.memory:
                        if clbit not in clbit_set:
                            num_bits += 1
                            clbit_set.append(clbit)

    return num_bits



def dump(
    qc: QuantumCircuit, 
    pt: Union[QuantumCircuit, List[QuantumCircuit]],
    filename: str = None
    ):
    """Dump the found pattern as a json file.

    Args:
        qc: The input to count qubits. 
        pt: The pattern to be searched.
        filename: The name of the json file

    """

    import json
    from pattern_matching import  match, pattern_counter

    file = {"Quantum Circuit": qc.qasm(), "Pattern": []}
    if isinstance(pt, QuantumCircuit):
        pt_matching = {"Pattern Circuit": pt.qasm(), "Count": pattern_counter(qc, pt, matcher="networkx"), "Matching":{}}
        for i, matching in enumerate(match(qc, pt)):
            mapping = get_bits_mapping(matching)
            pt_matching["Matching"][i] = {"Qubit Mapping": mapping[0], "Clbit Mapping": mapping[1]}
        file["Pattern"].append(pt_matching)
    elif isinstance(pt, list) and isinstance(pt[0], QuantumCircuit):
        for pattern in pt:
            pt_matching = {"Pattern Circuit": pattern.qasm(), "Count": pattern_counter(qc, pattern, matcher="networkx"), "Matching":{}}
            for i, matching in enumerate(match(qc, pattern)):
                mapping = get_bits_mapping(matching)
                pt_matching["Matching"][i] = {"Qubit Mapping": mapping[0], "Clbit Mapping": mapping[1]}
            file["Pattern"].append(pt_matching)
    else:
        raise Exception("Please input the right type for pattern (either QuantumCircuit or a list of QuantumCircuit)")
    
    if not filename:
        from datetime import datetime
        filename = "pattern_matching_" + str(datetime.now()).replace('-','_').replace(' ','_').replace(':','_')[:19] + ".json"

    with open(filename, 'w') as f:
        json.dump(file, f, indent = 4)
        print('Pattern matching information was successfully saved to "' + filename + '"')
