from typing import Dict, List, Tuple, Union, Optional, Generator
from qiskit import QuantumCircuit
from qiskit.qobj import Qobj
from qiskit.qobj.qasm_qobj import QasmQobj, QasmQobjInstruction
from circuit_to_dagdependency_antivirus import circuit_to_dagdependency_antivirus
from networkx import MultiDiGraph



def circuit_to_networkx(
    qc: Union[QuantumCircuit, QasmQobj, Qobj, List[QasmQobjInstruction]]
    ) -> MultiDiGraph:
    """Convert a quantum circuit to ``networkx.MultiDiGraph``

    Args:
        qc: The quantum circuit to be converted
    
    Yiled:
        The matching of a pattern in a quantum circuit.
    """

    qc_dag = circuit_to_dagdependency_antivirus(qc)
    qc_net = qc_dag.to_networkx()
    return qc_net



def check_matching(
    matching: Dict
    ) -> bool:
    """Check whether the matching is correct.
        This function is used to check the results of networkx isomorphism.
        Because the networkx isomorphism checking does not check qubits on which gates operate,
        it only returns the matching that has the same gates and order. In this case, the qubits
        mapping may not be satisfied. For example, the pattern is h(0) and cx(0, 1), but the
        matching is h(1) and cx(0, 1). This is viewed as a correct matching in the networkx
        isomorphism, but this should not be a matching in our antivirus program.

    Args:
        matching: item generated by ``networkx.algorithms.isomorphism.DiGraphMatcher.subgraph_isomorphisms_iter()``,
            which is the matching found by vf2 subgraph isomorphism algorithm.
    
    Return:
        Whether the matching is a correct matching.
    """

    qargs = {} # store qubits mapping of currently transversed gates
    cargs = {} # store clbits mapping of currently transversed gates

    # Eaching matching is a ``dict``. The key is the node in the first graph, and the corresponding value is the matching node in the second graph
    for node_qc, node_pt in matching.items():
        for qubit_qc, qubit_pt in zip(node_qc.qargs, node_pt.qargs):
            if qubit_qc.index in qargs:
                if qubit_pt.index != qargs[qubit_qc.index]:
                    return False
            else:
                qargs[qubit_qc.index] = qubit_pt.index
    
        for qubit_qc, qubit_pt in zip(node_qc.cargs, node_pt.cargs):
            if qubit_qc.index in cargs:
                if qubit_pt.index != cargs[qubit_qc.index]:
                    return False
            else:
                cargs[qubit_qc.index] = qubit_pt.index
    
    return True
